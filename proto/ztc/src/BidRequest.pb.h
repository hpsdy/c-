// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BidRequest.proto

#ifndef PROTOBUF_BidRequest_2eproto__INCLUDED
#define PROTOBUF_BidRequest_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_BidRequest_2eproto();
void protobuf_AssignDesc_BidRequest_2eproto();
void protobuf_ShutdownFile_BidRequest_2eproto();

class BidRequest;
class Imp;
class Banner;
class Native;
class GeneralTransInfo;
class Pair;
class Site;
class App;
class Device;
class Geo;
class User;
class NativeRequest;

enum AuctionType {
  FIRST_PRICE = 1,
  SECOND_PRICE = 2,
  FIXED_PRICE = 3
};
bool AuctionType_IsValid(int value);
const AuctionType AuctionType_MIN = FIRST_PRICE;
const AuctionType AuctionType_MAX = FIXED_PRICE;
const int AuctionType_ARRAYSIZE = AuctionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AuctionType_descriptor();
inline const ::std::string& AuctionType_Name(AuctionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AuctionType_descriptor(), value);
}
inline bool AuctionType_Parse(
    const ::std::string& name, AuctionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AuctionType>(
    AuctionType_descriptor(), name, value);
}
enum BannerAdType {
  XHTML_TEXT_AD = 1,
  XHTML_BANNER_AD = 2,
  JAVASCRIPT_AD = 3,
  IFRAME = 4
};
bool BannerAdType_IsValid(int value);
const BannerAdType BannerAdType_MIN = XHTML_TEXT_AD;
const BannerAdType BannerAdType_MAX = IFRAME;
const int BannerAdType_ARRAYSIZE = BannerAdType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BannerAdType_descriptor();
inline const ::std::string& BannerAdType_Name(BannerAdType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BannerAdType_descriptor(), value);
}
inline bool BannerAdType_Parse(
    const ::std::string& name, BannerAdType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BannerAdType>(
    BannerAdType_descriptor(), name, value);
}
enum CreativeAttribute {
  AUDIO_AUTO_PLAY = 1,
  AUDIO_USER_INITIATED = 2,
  EXPANDABLE_AUTOMATIC = 3,
  EXPANDABLE_CLICK_INITIATED = 4,
  EXPANDABLE_ROLLOVER_INITIATED = 5,
  VIDEO_IN_BANNER_AUTO_PLAY = 6,
  VIDEO_IN_BANNER_USER_INITIATED = 7,
  PROVOCATIVE_OR_SUGGESTIVE = 9,
  ANNOYING = 10,
  SURVEYS = 11,
  TEXT_ONLY = 12,
  USER_INTERACTIVE = 13,
  WINDOWS_DIALOG_OR_ALERT_STYLE = 14,
  HAS_AUDIO_ON_OFF_BUTTON = 15,
  AD_CAN_BE_SKIPPED = 16,
  FLASH = 17
};
bool CreativeAttribute_IsValid(int value);
const CreativeAttribute CreativeAttribute_MIN = AUDIO_AUTO_PLAY;
const CreativeAttribute CreativeAttribute_MAX = FLASH;
const int CreativeAttribute_ARRAYSIZE = CreativeAttribute_MAX + 1;

const ::google::protobuf::EnumDescriptor* CreativeAttribute_descriptor();
inline const ::std::string& CreativeAttribute_Name(CreativeAttribute value) {
  return ::google::protobuf::internal::NameOfEnum(
    CreativeAttribute_descriptor(), value);
}
inline bool CreativeAttribute_Parse(
    const ::std::string& name, CreativeAttribute* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CreativeAttribute>(
    CreativeAttribute_descriptor(), name, value);
}
enum APIFramework {
  VPAID_1 = 1,
  VPAID_2 = 2,
  MRAID_1 = 3,
  ORMMA = 4,
  MRAID_2 = 5
};
bool APIFramework_IsValid(int value);
const APIFramework APIFramework_MIN = VPAID_1;
const APIFramework APIFramework_MAX = MRAID_2;
const int APIFramework_ARRAYSIZE = APIFramework_MAX + 1;

const ::google::protobuf::EnumDescriptor* APIFramework_descriptor();
inline const ::std::string& APIFramework_Name(APIFramework value) {
  return ::google::protobuf::internal::NameOfEnum(
    APIFramework_descriptor(), value);
}
inline bool APIFramework_Parse(
    const ::std::string& name, APIFramework* value) {
  return ::google::protobuf::internal::ParseNamedEnum<APIFramework>(
    APIFramework_descriptor(), name, value);
}
enum AdPosition {
  UNKNOWN = 0,
  ABOVE_THE_FOLD = 1,
  DEPRECATED_LIKELY_BELOW_THE_FOLD = 2,
  BELOW_THE_FOLD = 3,
  HEADER = 4,
  FOOTER = 5,
  SIDEBAR = 6,
  AD_POSITION_FULLSCREEN = 7
};
bool AdPosition_IsValid(int value);
const AdPosition AdPosition_MIN = UNKNOWN;
const AdPosition AdPosition_MAX = AD_POSITION_FULLSCREEN;
const int AdPosition_ARRAYSIZE = AdPosition_MAX + 1;

const ::google::protobuf::EnumDescriptor* AdPosition_descriptor();
inline const ::std::string& AdPosition_Name(AdPosition value) {
  return ::google::protobuf::internal::NameOfEnum(
    AdPosition_descriptor(), value);
}
inline bool AdPosition_Parse(
    const ::std::string& name, AdPosition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AdPosition>(
    AdPosition_descriptor(), name, value);
}
enum VideoLinearity {
  LINEAR = 1,
  NON_LINEAR = 2
};
bool VideoLinearity_IsValid(int value);
const VideoLinearity VideoLinearity_MIN = LINEAR;
const VideoLinearity VideoLinearity_MAX = NON_LINEAR;
const int VideoLinearity_ARRAYSIZE = VideoLinearity_MAX + 1;

const ::google::protobuf::EnumDescriptor* VideoLinearity_descriptor();
inline const ::std::string& VideoLinearity_Name(VideoLinearity value) {
  return ::google::protobuf::internal::NameOfEnum(
    VideoLinearity_descriptor(), value);
}
inline bool VideoLinearity_Parse(
    const ::std::string& name, VideoLinearity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VideoLinearity>(
    VideoLinearity_descriptor(), name, value);
}
enum Protocol {
  VAST_1_0 = 1,
  VAST_2_0 = 2,
  VAST_3_0 = 3,
  VAST_1_0_WRAPPER = 4,
  VAST_2_0_WRAPPER = 5,
  VAST_3_0_WRAPPER = 6,
  VAST_4_0 = 7,
  VAST_4_0_WRAPPER = 8,
  DAAST_1_0 = 9,
  DAAST_1_0_WRAPPER = 10
};
bool Protocol_IsValid(int value);
const Protocol Protocol_MIN = VAST_1_0;
const Protocol Protocol_MAX = DAAST_1_0_WRAPPER;
const int Protocol_ARRAYSIZE = Protocol_MAX + 1;

const ::google::protobuf::EnumDescriptor* Protocol_descriptor();
inline const ::std::string& Protocol_Name(Protocol value) {
  return ::google::protobuf::internal::NameOfEnum(
    Protocol_descriptor(), value);
}
inline bool Protocol_Parse(
    const ::std::string& name, Protocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Protocol>(
    Protocol_descriptor(), name, value);
}
enum PlaybackMethod {
  AUTO_PLAY_SOUND_ON = 1,
  AUTO_PLAY_SOUND_OFF = 2,
  CLICK_TO_PLAY = 3,
  MOUSE_OVER = 4
};
bool PlaybackMethod_IsValid(int value);
const PlaybackMethod PlaybackMethod_MIN = AUTO_PLAY_SOUND_ON;
const PlaybackMethod PlaybackMethod_MAX = MOUSE_OVER;
const int PlaybackMethod_ARRAYSIZE = PlaybackMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlaybackMethod_descriptor();
inline const ::std::string& PlaybackMethod_Name(PlaybackMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlaybackMethod_descriptor(), value);
}
inline bool PlaybackMethod_Parse(
    const ::std::string& name, PlaybackMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlaybackMethod>(
    PlaybackMethod_descriptor(), name, value);
}
enum StartDelay {
  PRE_ROLL = 0,
  GENERIC_MID_ROLL = -1,
  GENERIC_POST_ROLL = -2
};
bool StartDelay_IsValid(int value);
const StartDelay StartDelay_MIN = GENERIC_POST_ROLL;
const StartDelay StartDelay_MAX = PRE_ROLL;
const int StartDelay_ARRAYSIZE = StartDelay_MAX + 1;

const ::google::protobuf::EnumDescriptor* StartDelay_descriptor();
inline const ::std::string& StartDelay_Name(StartDelay value) {
  return ::google::protobuf::internal::NameOfEnum(
    StartDelay_descriptor(), value);
}
inline bool StartDelay_Parse(
    const ::std::string& name, StartDelay* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StartDelay>(
    StartDelay_descriptor(), name, value);
}
enum ConnectionType {
  CONNECTION_UNKNOWN = 0,
  ETHERNET = 1,
  WIFI = 2,
  CELL_UNKNOWN = 3,
  CELL_2G = 4,
  CELL_3G = 5,
  CELL_4G = 6
};
bool ConnectionType_IsValid(int value);
const ConnectionType ConnectionType_MIN = CONNECTION_UNKNOWN;
const ConnectionType ConnectionType_MAX = CELL_4G;
const int ConnectionType_ARRAYSIZE = ConnectionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectionType_descriptor();
inline const ::std::string& ConnectionType_Name(ConnectionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectionType_descriptor(), value);
}
inline bool ConnectionType_Parse(
    const ::std::string& name, ConnectionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectionType>(
    ConnectionType_descriptor(), name, value);
}
enum ExpandableDirection {
  LEFT = 1,
  RIGHT = 2,
  UP = 3,
  DOWN = 4,
  EXPANDABLE_FULLSCREEN = 5
};
bool ExpandableDirection_IsValid(int value);
const ExpandableDirection ExpandableDirection_MIN = LEFT;
const ExpandableDirection ExpandableDirection_MAX = EXPANDABLE_FULLSCREEN;
const int ExpandableDirection_ARRAYSIZE = ExpandableDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExpandableDirection_descriptor();
inline const ::std::string& ExpandableDirection_Name(ExpandableDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExpandableDirection_descriptor(), value);
}
inline bool ExpandableDirection_Parse(
    const ::std::string& name, ExpandableDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExpandableDirection>(
    ExpandableDirection_descriptor(), name, value);
}
enum ContentDeliveryMethod {
  STREAMING = 1,
  PROGRESSIVE = 2
};
bool ContentDeliveryMethod_IsValid(int value);
const ContentDeliveryMethod ContentDeliveryMethod_MIN = STREAMING;
const ContentDeliveryMethod ContentDeliveryMethod_MAX = PROGRESSIVE;
const int ContentDeliveryMethod_ARRAYSIZE = ContentDeliveryMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContentDeliveryMethod_descriptor();
inline const ::std::string& ContentDeliveryMethod_Name(ContentDeliveryMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContentDeliveryMethod_descriptor(), value);
}
inline bool ContentDeliveryMethod_Parse(
    const ::std::string& name, ContentDeliveryMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContentDeliveryMethod>(
    ContentDeliveryMethod_descriptor(), name, value);
}
enum ContentContext {
  VIDEO = 1,
  GAME = 2,
  MUSIC = 3,
  APPLICATION = 4,
  TEXT = 5,
  OTHER = 6,
  CONTEXT_UNKNOWN = 7
};
bool ContentContext_IsValid(int value);
const ContentContext ContentContext_MIN = VIDEO;
const ContentContext ContentContext_MAX = CONTEXT_UNKNOWN;
const int ContentContext_ARRAYSIZE = ContentContext_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContentContext_descriptor();
inline const ::std::string& ContentContext_Name(ContentContext value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContentContext_descriptor(), value);
}
inline bool ContentContext_Parse(
    const ::std::string& name, ContentContext* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContentContext>(
    ContentContext_descriptor(), name, value);
}
enum ProductionQuality {
  QUALITY_UNKNOWN = 0,
  PROFESSIONAL = 1,
  PROSUMER = 2,
  USER_GENERATED = 3
};
bool ProductionQuality_IsValid(int value);
const ProductionQuality ProductionQuality_MIN = QUALITY_UNKNOWN;
const ProductionQuality ProductionQuality_MAX = USER_GENERATED;
const int ProductionQuality_ARRAYSIZE = ProductionQuality_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProductionQuality_descriptor();
inline const ::std::string& ProductionQuality_Name(ProductionQuality value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProductionQuality_descriptor(), value);
}
inline bool ProductionQuality_Parse(
    const ::std::string& name, ProductionQuality* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProductionQuality>(
    ProductionQuality_descriptor(), name, value);
}
enum LocationType {
  GPS_LOCATION = 1,
  IP = 2,
  USER_PROVIDED = 3
};
bool LocationType_IsValid(int value);
const LocationType LocationType_MIN = GPS_LOCATION;
const LocationType LocationType_MAX = USER_PROVIDED;
const int LocationType_ARRAYSIZE = LocationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LocationType_descriptor();
inline const ::std::string& LocationType_Name(LocationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LocationType_descriptor(), value);
}
inline bool LocationType_Parse(
    const ::std::string& name, LocationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LocationType>(
    LocationType_descriptor(), name, value);
}
enum LocationService {
  IP2LOCATION = 1,
  NEUSTAR = 2,
  MAXMIND = 3,
  NETAQUITY = 4
};
bool LocationService_IsValid(int value);
const LocationService LocationService_MIN = IP2LOCATION;
const LocationService LocationService_MAX = NETAQUITY;
const int LocationService_ARRAYSIZE = LocationService_MAX + 1;

const ::google::protobuf::EnumDescriptor* LocationService_descriptor();
inline const ::std::string& LocationService_Name(LocationService value) {
  return ::google::protobuf::internal::NameOfEnum(
    LocationService_descriptor(), value);
}
inline bool LocationService_Parse(
    const ::std::string& name, LocationService* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LocationService>(
    LocationService_descriptor(), name, value);
}
enum DeviceType {
  APP = 1,
  PC = 2,
  WAP = 3
};
bool DeviceType_IsValid(int value);
const DeviceType DeviceType_MIN = APP;
const DeviceType DeviceType_MAX = WAP;
const int DeviceType_ARRAYSIZE = DeviceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeviceType_descriptor();
inline const ::std::string& DeviceType_Name(DeviceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeviceType_descriptor(), value);
}
inline bool DeviceType_Parse(
    const ::std::string& name, DeviceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeviceType>(
    DeviceType_descriptor(), name, value);
}
enum CompanionType {
  STATIC = 1,
  HTML = 2,
  COMPANION_IFRAME = 3
};
bool CompanionType_IsValid(int value);
const CompanionType CompanionType_MIN = STATIC;
const CompanionType CompanionType_MAX = COMPANION_IFRAME;
const int CompanionType_ARRAYSIZE = CompanionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CompanionType_descriptor();
inline const ::std::string& CompanionType_Name(CompanionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CompanionType_descriptor(), value);
}
inline bool CompanionType_Parse(
    const ::std::string& name, CompanionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CompanionType>(
    CompanionType_descriptor(), name, value);
}
enum QAGMediaRating {
  ALL_AUDIENCES = 1,
  EVERYONE_OVER_12 = 2,
  MATURE = 3
};
bool QAGMediaRating_IsValid(int value);
const QAGMediaRating QAGMediaRating_MIN = ALL_AUDIENCES;
const QAGMediaRating QAGMediaRating_MAX = MATURE;
const int QAGMediaRating_ARRAYSIZE = QAGMediaRating_MAX + 1;

const ::google::protobuf::EnumDescriptor* QAGMediaRating_descriptor();
inline const ::std::string& QAGMediaRating_Name(QAGMediaRating value) {
  return ::google::protobuf::internal::NameOfEnum(
    QAGMediaRating_descriptor(), value);
}
inline bool QAGMediaRating_Parse(
    const ::std::string& name, QAGMediaRating* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QAGMediaRating>(
    QAGMediaRating_descriptor(), name, value);
}
enum NoBidReason {
  UNKNOWN_ERROR = 0,
  TECHNICAL_ERROR = 1,
  INVALID_REQUEST = 2,
  KNOWN_WEB_SPIDER = 3,
  SUSPECTED_NONHUMAN_TRAFFIC = 4,
  CLOUD_DATACENTER_PROXYIP = 5,
  UNSUPPORTED_DEVICE = 6,
  BLOCKED_PUBLISHER = 7,
  UNMATCHED_USER = 8
};
bool NoBidReason_IsValid(int value);
const NoBidReason NoBidReason_MIN = UNKNOWN_ERROR;
const NoBidReason NoBidReason_MAX = UNMATCHED_USER;
const int NoBidReason_ARRAYSIZE = NoBidReason_MAX + 1;

const ::google::protobuf::EnumDescriptor* NoBidReason_descriptor();
inline const ::std::string& NoBidReason_Name(NoBidReason value) {
  return ::google::protobuf::internal::NameOfEnum(
    NoBidReason_descriptor(), value);
}
inline bool NoBidReason_Parse(
    const ::std::string& name, NoBidReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NoBidReason>(
    NoBidReason_descriptor(), name, value);
}
enum FeedType {
  MUSIC_SERVICE = 1,
  BROADCAST = 2,
  PODCAST = 3
};
bool FeedType_IsValid(int value);
const FeedType FeedType_MIN = MUSIC_SERVICE;
const FeedType FeedType_MAX = PODCAST;
const int FeedType_ARRAYSIZE = FeedType_MAX + 1;

const ::google::protobuf::EnumDescriptor* FeedType_descriptor();
inline const ::std::string& FeedType_Name(FeedType value) {
  return ::google::protobuf::internal::NameOfEnum(
    FeedType_descriptor(), value);
}
inline bool FeedType_Parse(
    const ::std::string& name, FeedType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FeedType>(
    FeedType_descriptor(), name, value);
}
enum VolumeNormalizationMode {
  NONE = 0,
  AVERAGE_VOLUME = 1,
  PEAK_VOLUME = 2,
  LOUDNESS = 3,
  CUSTOM_VOLUME = 4
};
bool VolumeNormalizationMode_IsValid(int value);
const VolumeNormalizationMode VolumeNormalizationMode_MIN = NONE;
const VolumeNormalizationMode VolumeNormalizationMode_MAX = CUSTOM_VOLUME;
const int VolumeNormalizationMode_ARRAYSIZE = VolumeNormalizationMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* VolumeNormalizationMode_descriptor();
inline const ::std::string& VolumeNormalizationMode_Name(VolumeNormalizationMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    VolumeNormalizationMode_descriptor(), value);
}
inline bool VolumeNormalizationMode_Parse(
    const ::std::string& name, VolumeNormalizationMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VolumeNormalizationMode>(
    VolumeNormalizationMode_descriptor(), name, value);
}
enum LayoutId {
  CONTENT_WALL = 1,
  APP_WALL = 2,
  NEWS_FEED = 3,
  CHAT_LIST = 4,
  CAROUSEL = 5,
  CONTENT_STREAM = 6,
  GRID = 7
};
bool LayoutId_IsValid(int value);
const LayoutId LayoutId_MIN = CONTENT_WALL;
const LayoutId LayoutId_MAX = GRID;
const int LayoutId_ARRAYSIZE = LayoutId_MAX + 1;

const ::google::protobuf::EnumDescriptor* LayoutId_descriptor();
inline const ::std::string& LayoutId_Name(LayoutId value) {
  return ::google::protobuf::internal::NameOfEnum(
    LayoutId_descriptor(), value);
}
inline bool LayoutId_Parse(
    const ::std::string& name, LayoutId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LayoutId>(
    LayoutId_descriptor(), name, value);
}
enum AdUnitId {
  PAID_SEARCH_UNIT = 1,
  RECOMMENDATION_WIDGET = 2,
  PROMOTED_LISTING = 3,
  IAB_IN_AD_NATIVE = 4,
  ADUNITID_CUSTOM = 5
};
bool AdUnitId_IsValid(int value);
const AdUnitId AdUnitId_MIN = PAID_SEARCH_UNIT;
const AdUnitId AdUnitId_MAX = ADUNITID_CUSTOM;
const int AdUnitId_ARRAYSIZE = AdUnitId_MAX + 1;

const ::google::protobuf::EnumDescriptor* AdUnitId_descriptor();
inline const ::std::string& AdUnitId_Name(AdUnitId value) {
  return ::google::protobuf::internal::NameOfEnum(
    AdUnitId_descriptor(), value);
}
inline bool AdUnitId_Parse(
    const ::std::string& name, AdUnitId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AdUnitId>(
    AdUnitId_descriptor(), name, value);
}
enum ContextType {
  CONTENT = 1,
  SOCIAL = 2,
  PRODUCT = 3
};
bool ContextType_IsValid(int value);
const ContextType ContextType_MIN = CONTENT;
const ContextType ContextType_MAX = PRODUCT;
const int ContextType_ARRAYSIZE = ContextType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContextType_descriptor();
inline const ::std::string& ContextType_Name(ContextType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContextType_descriptor(), value);
}
inline bool ContextType_Parse(
    const ::std::string& name, ContextType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContextType>(
    ContextType_descriptor(), name, value);
}
enum ContextSubtype {
  CONTENT_GENERAL_OR_MIXED = 10,
  CONTENT_ARTICLE = 11,
  CONTENT_VIDEO = 12,
  CONTENT_AUDIO = 13,
  CONTENT_IMAGE = 14,
  CONTENT_USER_GENERATED = 15,
  SOCIAL_GENERAL = 20,
  SOCIAL_EMAIL = 21,
  SOCIAL_CHAT_IM = 22,
  PRODUCT_SELLING = 30,
  PRODUCT_MARKETPLACE = 31,
  PRODUCT_REVIEW = 32
};
bool ContextSubtype_IsValid(int value);
const ContextSubtype ContextSubtype_MIN = CONTENT_GENERAL_OR_MIXED;
const ContextSubtype ContextSubtype_MAX = PRODUCT_REVIEW;
const int ContextSubtype_ARRAYSIZE = ContextSubtype_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContextSubtype_descriptor();
inline const ::std::string& ContextSubtype_Name(ContextSubtype value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContextSubtype_descriptor(), value);
}
inline bool ContextSubtype_Parse(
    const ::std::string& name, ContextSubtype* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContextSubtype>(
    ContextSubtype_descriptor(), name, value);
}
enum PlacementType {
  IN_FEED = 1,
  ATOMIC_UNIT = 2,
  OUTSIDE = 3,
  RECOMMENDATION = 4
};
bool PlacementType_IsValid(int value);
const PlacementType PlacementType_MIN = IN_FEED;
const PlacementType PlacementType_MAX = RECOMMENDATION;
const int PlacementType_ARRAYSIZE = PlacementType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlacementType_descriptor();
inline const ::std::string& PlacementType_Name(PlacementType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlacementType_descriptor(), value);
}
inline bool PlacementType_Parse(
    const ::std::string& name, PlacementType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlacementType>(
    PlacementType_descriptor(), name, value);
}
enum DataAssetType {
  SPONSORED = 1,
  DESC = 2,
  RATING = 3,
  LIKES = 4,
  DOWNLOADS = 5,
  PRICE = 6,
  SALEPRICE = 7,
  PHONE = 8,
  ADDRESS = 9,
  DESC2 = 10,
  DISPLAYURL = 11,
  CTATEXT = 12
};
bool DataAssetType_IsValid(int value);
const DataAssetType DataAssetType_MIN = SPONSORED;
const DataAssetType DataAssetType_MAX = CTATEXT;
const int DataAssetType_ARRAYSIZE = DataAssetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DataAssetType_descriptor();
inline const ::std::string& DataAssetType_Name(DataAssetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DataAssetType_descriptor(), value);
}
inline bool DataAssetType_Parse(
    const ::std::string& name, DataAssetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DataAssetType>(
    DataAssetType_descriptor(), name, value);
}
enum ImageAssetType {
  ICON = 1,
  LOGO = 2,
  MAIN = 3
};
bool ImageAssetType_IsValid(int value);
const ImageAssetType ImageAssetType_MIN = ICON;
const ImageAssetType ImageAssetType_MAX = MAIN;
const int ImageAssetType_ARRAYSIZE = ImageAssetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageAssetType_descriptor();
inline const ::std::string& ImageAssetType_Name(ImageAssetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageAssetType_descriptor(), value);
}
inline bool ImageAssetType_Parse(
    const ::std::string& name, ImageAssetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageAssetType>(
    ImageAssetType_descriptor(), name, value);
}
// ===================================================================

class BidRequest : public ::google::protobuf::Message {
 public:
  BidRequest();
  virtual ~BidRequest();
  
  BidRequest(const BidRequest& from);
  
  inline BidRequest& operator=(const BidRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BidRequest& default_instance();
  
  void Swap(BidRequest* other);
  
  // implements Message ----------------------------------------------
  
  BidRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BidRequest& from);
  void MergeFrom(const BidRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  
  // repeated .Imp imp = 2;
  inline int imp_size() const;
  inline void clear_imp();
  static const int kImpFieldNumber = 2;
  inline const ::Imp& imp(int index) const;
  inline ::Imp* mutable_imp(int index);
  inline ::Imp* add_imp();
  inline const ::google::protobuf::RepeatedPtrField< ::Imp >&
      imp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Imp >*
      mutable_imp();
  
  // optional .Site site = 3;
  inline bool has_site() const;
  inline void clear_site();
  static const int kSiteFieldNumber = 3;
  inline const ::Site& site() const;
  inline ::Site* mutable_site();
  
  // optional .App app = 4;
  inline bool has_app() const;
  inline void clear_app();
  static const int kAppFieldNumber = 4;
  inline const ::App& app() const;
  inline ::App* mutable_app();
  
  // optional .Device device = 5;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 5;
  inline const ::Device& device() const;
  inline ::Device* mutable_device();
  
  // optional .User user = 6;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 6;
  inline const ::User& user() const;
  inline ::User* mutable_user();
  
  // optional .AuctionType at = 7;
  inline bool has_at() const;
  inline void clear_at();
  static const int kAtFieldNumber = 7;
  inline AuctionType at() const;
  inline void set_at(AuctionType value);
  
  // optional int32 tmax = 8;
  inline bool has_tmax() const;
  inline void clear_tmax();
  static const int kTmaxFieldNumber = 8;
  inline ::google::protobuf::int32 tmax() const;
  inline void set_tmax(::google::protobuf::int32 value);
  
  // repeated int32 experiment_id_list = 100;
  inline int experiment_id_list_size() const;
  inline void clear_experiment_id_list();
  static const int kExperimentIdListFieldNumber = 100;
  inline ::google::protobuf::int32 experiment_id_list(int index) const;
  inline void set_experiment_id_list(int index, ::google::protobuf::int32 value);
  inline void add_experiment_id_list(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      experiment_id_list() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_experiment_id_list();
  
  // optional string user_dislike_ad = 101;
  inline bool has_user_dislike_ad() const;
  inline void clear_user_dislike_ad();
  static const int kUserDislikeAdFieldNumber = 101;
  inline const ::std::string& user_dislike_ad() const;
  inline void set_user_dislike_ad(const ::std::string& value);
  inline void set_user_dislike_ad(const char* value);
  inline void set_user_dislike_ad(const char* value, size_t size);
  inline ::std::string* mutable_user_dislike_ad();
  
  // repeated .GeneralTransInfo trans_info_list = 102;
  inline int trans_info_list_size() const;
  inline void clear_trans_info_list();
  static const int kTransInfoListFieldNumber = 102;
  inline const ::GeneralTransInfo& trans_info_list(int index) const;
  inline ::GeneralTransInfo* mutable_trans_info_list(int index);
  inline ::GeneralTransInfo* add_trans_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::GeneralTransInfo >&
      trans_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::GeneralTransInfo >*
      mutable_trans_info_list();
  
  // @@protoc_insertion_point(class_scope:BidRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  ::google::protobuf::RepeatedPtrField< ::Imp > imp_;
  ::Site* site_;
  ::App* app_;
  ::Device* device_;
  ::User* user_;
  int at_;
  ::google::protobuf::int32 tmax_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > experiment_id_list_;
  ::std::string* user_dislike_ad_;
  static const ::std::string _default_user_dislike_ad_;
  ::google::protobuf::RepeatedPtrField< ::GeneralTransInfo > trans_info_list_;
  friend void  protobuf_AddDesc_BidRequest_2eproto();
  friend void protobuf_AssignDesc_BidRequest_2eproto();
  friend void protobuf_ShutdownFile_BidRequest_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BidRequest* default_instance_;
};
// -------------------------------------------------------------------

class Imp : public ::google::protobuf::Message {
 public:
  Imp();
  virtual ~Imp();
  
  Imp(const Imp& from);
  
  inline Imp& operator=(const Imp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Imp& default_instance();
  
  void Swap(Imp* other);
  
  // implements Message ----------------------------------------------
  
  Imp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Imp& from);
  void MergeFrom(const Imp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  
  // optional .Banner banner = 2;
  inline bool has_banner() const;
  inline void clear_banner();
  static const int kBannerFieldNumber = 2;
  inline const ::Banner& banner() const;
  inline ::Banner* mutable_banner();
  
  // optional string tagid = 7;
  inline bool has_tagid() const;
  inline void clear_tagid();
  static const int kTagidFieldNumber = 7;
  inline const ::std::string& tagid() const;
  inline void set_tagid(const ::std::string& value);
  inline void set_tagid(const char* value);
  inline void set_tagid(const char* value, size_t size);
  inline ::std::string* mutable_tagid();
  
  // optional double bidfloor = 8;
  inline bool has_bidfloor() const;
  inline void clear_bidfloor();
  static const int kBidfloorFieldNumber = 8;
  inline double bidfloor() const;
  inline void set_bidfloor(double value);
  
  // optional bool secure = 12;
  inline bool has_secure() const;
  inline void clear_secure();
  static const int kSecureFieldNumber = 12;
  inline bool secure() const;
  inline void set_secure(bool value);
  
  // optional .Native native = 13;
  inline bool has_native() const;
  inline void clear_native();
  static const int kNativeFieldNumber = 13;
  inline const ::Native& native() const;
  inline ::Native* mutable_native();
  
  // repeated string templelist = 100;
  inline int templelist_size() const;
  inline void clear_templelist();
  static const int kTemplelistFieldNumber = 100;
  inline const ::std::string& templelist(int index) const;
  inline ::std::string* mutable_templelist(int index);
  inline void set_templelist(int index, const ::std::string& value);
  inline void set_templelist(int index, const char* value);
  inline void set_templelist(int index, const char* value, size_t size);
  inline ::std::string* add_templelist();
  inline void add_templelist(const ::std::string& value);
  inline void add_templelist(const char* value);
  inline void add_templelist(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& templelist() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_templelist();
  
  // @@protoc_insertion_point(class_scope:Imp)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  ::Banner* banner_;
  ::std::string* tagid_;
  static const ::std::string _default_tagid_;
  double bidfloor_;
  bool secure_;
  ::Native* native_;
  ::google::protobuf::RepeatedPtrField< ::std::string> templelist_;
  friend void  protobuf_AddDesc_BidRequest_2eproto();
  friend void protobuf_AssignDesc_BidRequest_2eproto();
  friend void protobuf_ShutdownFile_BidRequest_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Imp* default_instance_;
};
// -------------------------------------------------------------------

class Banner : public ::google::protobuf::Message {
 public:
  Banner();
  virtual ~Banner();
  
  Banner(const Banner& from);
  
  inline Banner& operator=(const Banner& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Banner& default_instance();
  
  void Swap(Banner* other);
  
  // implements Message ----------------------------------------------
  
  Banner* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Banner& from);
  void MergeFrom(const Banner& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 w = 1;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 1;
  inline ::google::protobuf::int32 w() const;
  inline void set_w(::google::protobuf::int32 value);
  
  // optional int32 h = 2;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 2;
  inline ::google::protobuf::int32 h() const;
  inline void set_h(::google::protobuf::int32 value);
  
  // optional .AdPosition pos = 4;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 4;
  inline AdPosition pos() const;
  inline void set_pos(AdPosition value);
  
  // @@protoc_insertion_point(class_scope:Banner)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 w_;
  ::google::protobuf::int32 h_;
  int pos_;
  friend void  protobuf_AddDesc_BidRequest_2eproto();
  friend void protobuf_AssignDesc_BidRequest_2eproto();
  friend void protobuf_ShutdownFile_BidRequest_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Banner* default_instance_;
};
// -------------------------------------------------------------------

class Native : public ::google::protobuf::Message {
 public:
  Native();
  virtual ~Native();
  
  Native(const Native& from);
  
  inline Native& operator=(const Native& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Native& default_instance();
  
  void Swap(Native* other);
  
  // implements Message ----------------------------------------------
  
  Native* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Native& from);
  void MergeFrom(const Native& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .NativeRequest request_native = 50;
  inline bool has_request_native() const;
  inline void clear_request_native();
  static const int kRequestNativeFieldNumber = 50;
  inline const ::NativeRequest& request_native() const;
  inline ::NativeRequest* mutable_request_native();
  
  // @@protoc_insertion_point(class_scope:Native)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::NativeRequest* request_native_;
  friend void  protobuf_AddDesc_BidRequest_2eproto();
  friend void protobuf_AssignDesc_BidRequest_2eproto();
  friend void protobuf_ShutdownFile_BidRequest_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Native* default_instance_;
};
// -------------------------------------------------------------------

class GeneralTransInfo : public ::google::protobuf::Message {
 public:
  GeneralTransInfo();
  virtual ~GeneralTransInfo();
  
  GeneralTransInfo(const GeneralTransInfo& from);
  
  inline GeneralTransInfo& operator=(const GeneralTransInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GeneralTransInfo& default_instance();
  
  void Swap(GeneralTransInfo* other);
  
  // implements Message ----------------------------------------------
  
  GeneralTransInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GeneralTransInfo& from);
  void MergeFrom(const GeneralTransInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  
  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // repeated .Pair value_list = 3;
  inline int value_list_size() const;
  inline void clear_value_list();
  static const int kValueListFieldNumber = 3;
  inline const ::Pair& value_list(int index) const;
  inline ::Pair* mutable_value_list(int index);
  inline ::Pair* add_value_list();
  inline const ::google::protobuf::RepeatedPtrField< ::Pair >&
      value_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::Pair >*
      mutable_value_list();
  
  // @@protoc_insertion_point(class_scope:GeneralTransInfo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  ::google::protobuf::RepeatedPtrField< ::Pair > value_list_;
  friend void  protobuf_AddDesc_BidRequest_2eproto();
  friend void protobuf_AssignDesc_BidRequest_2eproto();
  friend void protobuf_ShutdownFile_BidRequest_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static GeneralTransInfo* default_instance_;
};
// -------------------------------------------------------------------

class Pair : public ::google::protobuf::Message {
 public:
  Pair();
  virtual ~Pair();
  
  Pair(const Pair& from);
  
  inline Pair& operator=(const Pair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Pair& default_instance();
  
  void Swap(Pair* other);
  
  // implements Message ----------------------------------------------
  
  Pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pair& from);
  void MergeFrom(const Pair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  
  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // @@protoc_insertion_point(class_scope:Pair)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* key_;
  static const ::std::string _default_key_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  friend void  protobuf_AddDesc_BidRequest_2eproto();
  friend void protobuf_AssignDesc_BidRequest_2eproto();
  friend void protobuf_ShutdownFile_BidRequest_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Pair* default_instance_;
};
// -------------------------------------------------------------------

class Site : public ::google::protobuf::Message {
 public:
  Site();
  virtual ~Site();
  
  Site(const Site& from);
  
  inline Site& operator=(const Site& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Site& default_instance();
  
  void Swap(Site* other);
  
  // implements Message ----------------------------------------------
  
  Site* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Site& from);
  void MergeFrom(const Site& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string domain = 3;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 3;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  
  // optional string page = 7;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 7;
  inline const ::std::string& page() const;
  inline void set_page(const ::std::string& value);
  inline void set_page(const char* value);
  inline void set_page(const char* value, size_t size);
  inline ::std::string* mutable_page();
  
  // optional string ref = 9;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 9;
  inline const ::std::string& ref() const;
  inline void set_ref(const ::std::string& value);
  inline void set_ref(const char* value);
  inline void set_ref(const char* value, size_t size);
  inline ::std::string* mutable_ref();
  
  // @@protoc_insertion_point(class_scope:Site)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* domain_;
  static const ::std::string _default_domain_;
  ::std::string* page_;
  static const ::std::string _default_page_;
  ::std::string* ref_;
  static const ::std::string _default_ref_;
  friend void  protobuf_AddDesc_BidRequest_2eproto();
  friend void protobuf_AssignDesc_BidRequest_2eproto();
  friend void protobuf_ShutdownFile_BidRequest_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Site* default_instance_;
};
// -------------------------------------------------------------------

class App : public ::google::protobuf::Message {
 public:
  App();
  virtual ~App();
  
  App(const App& from);
  
  inline App& operator=(const App& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const App& default_instance();
  
  void Swap(App* other);
  
  // implements Message ----------------------------------------------
  
  App* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const App& from);
  void MergeFrom(const App& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string ver = 7;
  inline bool has_ver() const;
  inline void clear_ver();
  static const int kVerFieldNumber = 7;
  inline const ::std::string& ver() const;
  inline void set_ver(const ::std::string& value);
  inline void set_ver(const char* value);
  inline void set_ver(const char* value, size_t size);
  inline ::std::string* mutable_ver();
  
  // optional string bundle = 8;
  inline bool has_bundle() const;
  inline void clear_bundle();
  static const int kBundleFieldNumber = 8;
  inline const ::std::string& bundle() const;
  inline void set_bundle(const ::std::string& value);
  inline void set_bundle(const char* value);
  inline void set_bundle(const char* value, size_t size);
  inline ::std::string* mutable_bundle();
  
  // @@protoc_insertion_point(class_scope:App)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* ver_;
  static const ::std::string _default_ver_;
  ::std::string* bundle_;
  static const ::std::string _default_bundle_;
  friend void  protobuf_AddDesc_BidRequest_2eproto();
  friend void protobuf_AssignDesc_BidRequest_2eproto();
  friend void protobuf_ShutdownFile_BidRequest_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static App* default_instance_;
};
// -------------------------------------------------------------------

class Device : public ::google::protobuf::Message {
 public:
  Device();
  virtual ~Device();
  
  Device(const Device& from);
  
  inline Device& operator=(const Device& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Device& default_instance();
  
  void Swap(Device* other);
  
  // implements Message ----------------------------------------------
  
  Device* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Device& from);
  void MergeFrom(const Device& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string ua = 2;
  inline bool has_ua() const;
  inline void clear_ua();
  static const int kUaFieldNumber = 2;
  inline const ::std::string& ua() const;
  inline void set_ua(const ::std::string& value);
  inline void set_ua(const char* value);
  inline void set_ua(const char* value, size_t size);
  inline ::std::string* mutable_ua();
  
  // optional string ip = 3;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 3;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  
  // optional .Geo geo = 4;
  inline bool has_geo() const;
  inline void clear_geo();
  static const int kGeoFieldNumber = 4;
  inline const ::Geo& geo() const;
  inline ::Geo* mutable_geo();
  
  // optional string ipv6 = 9;
  inline bool has_ipv6() const;
  inline void clear_ipv6();
  static const int kIpv6FieldNumber = 9;
  inline const ::std::string& ipv6() const;
  inline void set_ipv6(const ::std::string& value);
  inline void set_ipv6(const char* value);
  inline void set_ipv6(const char* value, size_t size);
  inline ::std::string* mutable_ipv6();
  
  // optional string model = 13;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 13;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  
  // optional string os = 14;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOsFieldNumber = 14;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  
  // optional string osv = 15;
  inline bool has_osv() const;
  inline void clear_osv();
  static const int kOsvFieldNumber = 15;
  inline const ::std::string& osv() const;
  inline void set_osv(const ::std::string& value);
  inline void set_osv(const char* value);
  inline void set_osv(const char* value, size_t size);
  inline ::std::string* mutable_osv();
  
  // optional int32 w = 25;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 25;
  inline ::google::protobuf::int32 w() const;
  inline void set_w(::google::protobuf::int32 value);
  
  // optional int32 h = 26;
  inline bool has_h() const;
  inline void clear_h();
  static const int kHFieldNumber = 26;
  inline ::google::protobuf::int32 h() const;
  inline void set_h(::google::protobuf::int32 value);
  
  // optional .ConnectionType connectiontype = 17;
  inline bool has_connectiontype() const;
  inline void clear_connectiontype();
  static const int kConnectiontypeFieldNumber = 17;
  inline ConnectionType connectiontype() const;
  inline void set_connectiontype(ConnectionType value);
  
  // optional .DeviceType devicetype = 18;
  inline bool has_devicetype() const;
  inline void clear_devicetype();
  static const int kDevicetypeFieldNumber = 18;
  inline DeviceType devicetype() const;
  inline void set_devicetype(DeviceType value);
  
  // optional string ifa = 20;
  inline bool has_ifa() const;
  inline void clear_ifa();
  static const int kIfaFieldNumber = 20;
  inline const ::std::string& ifa() const;
  inline void set_ifa(const ::std::string& value);
  inline void set_ifa(const char* value);
  inline void set_ifa(const char* value, size_t size);
  inline ::std::string* mutable_ifa();
  
  // optional string macsha1 = 21;
  inline bool has_macsha1() const;
  inline void clear_macsha1();
  static const int kMacsha1FieldNumber = 21;
  inline const ::std::string& macsha1() const;
  inline void set_macsha1(const ::std::string& value);
  inline void set_macsha1(const char* value);
  inline void set_macsha1(const char* value, size_t size);
  inline ::std::string* mutable_macsha1();
  
  // optional string macmd5 = 22;
  inline bool has_macmd5() const;
  inline void clear_macmd5();
  static const int kMacmd5FieldNumber = 22;
  inline const ::std::string& macmd5() const;
  inline void set_macmd5(const ::std::string& value);
  inline void set_macmd5(const char* value);
  inline void set_macmd5(const char* value, size_t size);
  inline ::std::string* mutable_macmd5();
  
  // optional string cuid = 100;
  inline bool has_cuid() const;
  inline void clear_cuid();
  static const int kCuidFieldNumber = 100;
  inline const ::std::string& cuid() const;
  inline void set_cuid(const ::std::string& value);
  inline void set_cuid(const char* value);
  inline void set_cuid(const char* value, size_t size);
  inline ::std::string* mutable_cuid();
  
  // optional string android_id = 101;
  inline bool has_android_id() const;
  inline void clear_android_id();
  static const int kAndroidIdFieldNumber = 101;
  inline const ::std::string& android_id() const;
  inline void set_android_id(const ::std::string& value);
  inline void set_android_id(const char* value);
  inline void set_android_id(const char* value, size_t size);
  inline ::std::string* mutable_android_id();
  
  // @@protoc_insertion_point(class_scope:Device)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* ua_;
  static const ::std::string _default_ua_;
  ::std::string* ip_;
  static const ::std::string _default_ip_;
  ::Geo* geo_;
  ::std::string* ipv6_;
  static const ::std::string _default_ipv6_;
  ::std::string* model_;
  static const ::std::string _default_model_;
  ::std::string* os_;
  static const ::std::string _default_os_;
  ::std::string* osv_;
  static const ::std::string _default_osv_;
  ::google::protobuf::int32 w_;
  ::google::protobuf::int32 h_;
  int connectiontype_;
  int devicetype_;
  ::std::string* ifa_;
  static const ::std::string _default_ifa_;
  ::std::string* macsha1_;
  static const ::std::string _default_macsha1_;
  ::std::string* macmd5_;
  static const ::std::string _default_macmd5_;
  ::std::string* cuid_;
  static const ::std::string _default_cuid_;
  ::std::string* android_id_;
  static const ::std::string _default_android_id_;
  friend void  protobuf_AddDesc_BidRequest_2eproto();
  friend void protobuf_AssignDesc_BidRequest_2eproto();
  friend void protobuf_ShutdownFile_BidRequest_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Device* default_instance_;
};
// -------------------------------------------------------------------

class Geo : public ::google::protobuf::Message {
 public:
  Geo();
  virtual ~Geo();
  
  Geo(const Geo& from);
  
  inline Geo& operator=(const Geo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Geo& default_instance();
  
  void Swap(Geo* other);
  
  // implements Message ----------------------------------------------
  
  Geo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Geo& from);
  void MergeFrom(const Geo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double lat = 1;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 1;
  inline double lat() const;
  inline void set_lat(double value);
  
  // optional double lon = 2;
  inline bool has_lon() const;
  inline void clear_lon();
  static const int kLonFieldNumber = 2;
  inline double lon() const;
  inline void set_lon(double value);
  
  // optional .LocationType type = 9;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 9;
  inline LocationType type() const;
  inline void set_type(LocationType value);
  
  // @@protoc_insertion_point(class_scope:Geo)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  double lat_;
  double lon_;
  int type_;
  friend void  protobuf_AddDesc_BidRequest_2eproto();
  friend void protobuf_AssignDesc_BidRequest_2eproto();
  friend void protobuf_ShutdownFile_BidRequest_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Geo* default_instance_;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message {
 public:
  User();
  virtual ~User();
  
  User(const User& from);
  
  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();
  
  void Swap(User* other);
  
  // implements Message ----------------------------------------------
  
  User* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  
  // optional string buyeruid = 2;
  inline bool has_buyeruid() const;
  inline void clear_buyeruid();
  static const int kBuyeruidFieldNumber = 2;
  inline const ::std::string& buyeruid() const;
  inline void set_buyeruid(const ::std::string& value);
  inline void set_buyeruid(const char* value);
  inline void set_buyeruid(const char* value, size_t size);
  inline ::std::string* mutable_buyeruid();
  
  // optional int32 yob = 3;
  inline bool has_yob() const;
  inline void clear_yob();
  static const int kYobFieldNumber = 3;
  inline ::google::protobuf::int32 yob() const;
  inline void set_yob(::google::protobuf::int32 value);
  
  // optional string gender = 4;
  inline bool has_gender() const;
  inline void clear_gender();
  static const int kGenderFieldNumber = 4;
  inline const ::std::string& gender() const;
  inline void set_gender(const ::std::string& value);
  inline void set_gender(const char* value);
  inline void set_gender(const char* value, size_t size);
  inline ::std::string* mutable_gender();
  
  // optional string keywords = 5;
  inline bool has_keywords() const;
  inline void clear_keywords();
  static const int kKeywordsFieldNumber = 5;
  inline const ::std::string& keywords() const;
  inline void set_keywords(const ::std::string& value);
  inline void set_keywords(const char* value);
  inline void set_keywords(const char* value, size_t size);
  inline ::std::string* mutable_keywords();
  
  // optional .Geo geo = 7;
  inline bool has_geo() const;
  inline void clear_geo();
  static const int kGeoFieldNumber = 7;
  inline const ::Geo& geo() const;
  inline ::Geo* mutable_geo();
  
  // optional string baiduid = 100;
  inline bool has_baiduid() const;
  inline void clear_baiduid();
  static const int kBaiduidFieldNumber = 100;
  inline const ::std::string& baiduid() const;
  inline void set_baiduid(const ::std::string& value);
  inline void set_baiduid(const char* value);
  inline void set_baiduid(const char* value, size_t size);
  inline ::std::string* mutable_baiduid();
  
  // @@protoc_insertion_point(class_scope:User)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  ::std::string* buyeruid_;
  static const ::std::string _default_buyeruid_;
  ::google::protobuf::int32 yob_;
  ::std::string* gender_;
  static const ::std::string _default_gender_;
  ::std::string* keywords_;
  static const ::std::string _default_keywords_;
  ::Geo* geo_;
  ::std::string* baiduid_;
  static const ::std::string _default_baiduid_;
  friend void  protobuf_AddDesc_BidRequest_2eproto();
  friend void protobuf_AssignDesc_BidRequest_2eproto();
  friend void protobuf_ShutdownFile_BidRequest_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static User* default_instance_;
};
// -------------------------------------------------------------------

class NativeRequest : public ::google::protobuf::Message {
 public:
  NativeRequest();
  virtual ~NativeRequest();
  
  NativeRequest(const NativeRequest& from);
  
  inline NativeRequest& operator=(const NativeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const NativeRequest& default_instance();
  
  void Swap(NativeRequest* other);
  
  // implements Message ----------------------------------------------
  
  NativeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NativeRequest& from);
  void MergeFrom(const NativeRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .LayoutId layout = 2;
  inline bool has_layout() const;
  inline void clear_layout();
  static const int kLayoutFieldNumber = 2;
  inline LayoutId layout() const;
  inline void set_layout(LayoutId value);
  
  // optional .ContextType context = 7;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 7;
  inline ContextType context() const;
  inline void set_context(ContextType value);
  
  // optional .ContextSubtype contextsubtype = 8;
  inline bool has_contextsubtype() const;
  inline void clear_contextsubtype();
  static const int kContextsubtypeFieldNumber = 8;
  inline ContextSubtype contextsubtype() const;
  inline void set_contextsubtype(ContextSubtype value);
  
  // optional .PlacementType plcmttype = 9;
  inline bool has_plcmttype() const;
  inline void clear_plcmttype();
  static const int kPlcmttypeFieldNumber = 9;
  inline PlacementType plcmttype() const;
  inline void set_plcmttype(PlacementType value);
  
  // optional int32 plcmtcnt = 4;
  inline bool has_plcmtcnt() const;
  inline void clear_plcmtcnt();
  static const int kPlcmtcntFieldNumber = 4;
  inline ::google::protobuf::int32 plcmtcnt() const;
  inline void set_plcmtcnt(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:NativeRequest)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int layout_;
  int context_;
  int contextsubtype_;
  int plcmttype_;
  ::google::protobuf::int32 plcmtcnt_;
  friend void  protobuf_AddDesc_BidRequest_2eproto();
  friend void protobuf_AssignDesc_BidRequest_2eproto();
  friend void protobuf_ShutdownFile_BidRequest_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static NativeRequest* default_instance_;
};
// ===================================================================


// ===================================================================

// BidRequest

// required string id = 1;
inline bool BidRequest::has_id() const {
  return _has_bit(0);
}
inline void BidRequest::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& BidRequest::id() const {
  return *id_;
}
inline void BidRequest::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void BidRequest::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void BidRequest::set_id(const char* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BidRequest::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// repeated .Imp imp = 2;
inline int BidRequest::imp_size() const {
  return imp_.size();
}
inline void BidRequest::clear_imp() {
  imp_.Clear();
}
inline const ::Imp& BidRequest::imp(int index) const {
  return imp_.Get(index);
}
inline ::Imp* BidRequest::mutable_imp(int index) {
  return imp_.Mutable(index);
}
inline ::Imp* BidRequest::add_imp() {
  return imp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Imp >&
BidRequest::imp() const {
  return imp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Imp >*
BidRequest::mutable_imp() {
  return &imp_;
}

// optional .Site site = 3;
inline bool BidRequest::has_site() const {
  return _has_bit(2);
}
inline void BidRequest::clear_site() {
  if (site_ != NULL) site_->::Site::Clear();
  _clear_bit(2);
}
inline const ::Site& BidRequest::site() const {
  return site_ != NULL ? *site_ : *default_instance_->site_;
}
inline ::Site* BidRequest::mutable_site() {
  _set_bit(2);
  if (site_ == NULL) site_ = new ::Site;
  return site_;
}

// optional .App app = 4;
inline bool BidRequest::has_app() const {
  return _has_bit(3);
}
inline void BidRequest::clear_app() {
  if (app_ != NULL) app_->::App::Clear();
  _clear_bit(3);
}
inline const ::App& BidRequest::app() const {
  return app_ != NULL ? *app_ : *default_instance_->app_;
}
inline ::App* BidRequest::mutable_app() {
  _set_bit(3);
  if (app_ == NULL) app_ = new ::App;
  return app_;
}

// optional .Device device = 5;
inline bool BidRequest::has_device() const {
  return _has_bit(4);
}
inline void BidRequest::clear_device() {
  if (device_ != NULL) device_->::Device::Clear();
  _clear_bit(4);
}
inline const ::Device& BidRequest::device() const {
  return device_ != NULL ? *device_ : *default_instance_->device_;
}
inline ::Device* BidRequest::mutable_device() {
  _set_bit(4);
  if (device_ == NULL) device_ = new ::Device;
  return device_;
}

// optional .User user = 6;
inline bool BidRequest::has_user() const {
  return _has_bit(5);
}
inline void BidRequest::clear_user() {
  if (user_ != NULL) user_->::User::Clear();
  _clear_bit(5);
}
inline const ::User& BidRequest::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::User* BidRequest::mutable_user() {
  _set_bit(5);
  if (user_ == NULL) user_ = new ::User;
  return user_;
}

// optional .AuctionType at = 7;
inline bool BidRequest::has_at() const {
  return _has_bit(6);
}
inline void BidRequest::clear_at() {
  at_ = 1;
  _clear_bit(6);
}
inline AuctionType BidRequest::at() const {
  return static_cast< AuctionType >(at_);
}
inline void BidRequest::set_at(AuctionType value) {
  GOOGLE_DCHECK(AuctionType_IsValid(value));
  _set_bit(6);
  at_ = value;
}

// optional int32 tmax = 8;
inline bool BidRequest::has_tmax() const {
  return _has_bit(7);
}
inline void BidRequest::clear_tmax() {
  tmax_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 BidRequest::tmax() const {
  return tmax_;
}
inline void BidRequest::set_tmax(::google::protobuf::int32 value) {
  _set_bit(7);
  tmax_ = value;
}

// repeated int32 experiment_id_list = 100;
inline int BidRequest::experiment_id_list_size() const {
  return experiment_id_list_.size();
}
inline void BidRequest::clear_experiment_id_list() {
  experiment_id_list_.Clear();
}
inline ::google::protobuf::int32 BidRequest::experiment_id_list(int index) const {
  return experiment_id_list_.Get(index);
}
inline void BidRequest::set_experiment_id_list(int index, ::google::protobuf::int32 value) {
  experiment_id_list_.Set(index, value);
}
inline void BidRequest::add_experiment_id_list(::google::protobuf::int32 value) {
  experiment_id_list_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BidRequest::experiment_id_list() const {
  return experiment_id_list_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BidRequest::mutable_experiment_id_list() {
  return &experiment_id_list_;
}

// optional string user_dislike_ad = 101;
inline bool BidRequest::has_user_dislike_ad() const {
  return _has_bit(9);
}
inline void BidRequest::clear_user_dislike_ad() {
  if (user_dislike_ad_ != &_default_user_dislike_ad_) {
    user_dislike_ad_->clear();
  }
  _clear_bit(9);
}
inline const ::std::string& BidRequest::user_dislike_ad() const {
  return *user_dislike_ad_;
}
inline void BidRequest::set_user_dislike_ad(const ::std::string& value) {
  _set_bit(9);
  if (user_dislike_ad_ == &_default_user_dislike_ad_) {
    user_dislike_ad_ = new ::std::string;
  }
  user_dislike_ad_->assign(value);
}
inline void BidRequest::set_user_dislike_ad(const char* value) {
  _set_bit(9);
  if (user_dislike_ad_ == &_default_user_dislike_ad_) {
    user_dislike_ad_ = new ::std::string;
  }
  user_dislike_ad_->assign(value);
}
inline void BidRequest::set_user_dislike_ad(const char* value, size_t size) {
  _set_bit(9);
  if (user_dislike_ad_ == &_default_user_dislike_ad_) {
    user_dislike_ad_ = new ::std::string;
  }
  user_dislike_ad_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BidRequest::mutable_user_dislike_ad() {
  _set_bit(9);
  if (user_dislike_ad_ == &_default_user_dislike_ad_) {
    user_dislike_ad_ = new ::std::string;
  }
  return user_dislike_ad_;
}

// repeated .GeneralTransInfo trans_info_list = 102;
inline int BidRequest::trans_info_list_size() const {
  return trans_info_list_.size();
}
inline void BidRequest::clear_trans_info_list() {
  trans_info_list_.Clear();
}
inline const ::GeneralTransInfo& BidRequest::trans_info_list(int index) const {
  return trans_info_list_.Get(index);
}
inline ::GeneralTransInfo* BidRequest::mutable_trans_info_list(int index) {
  return trans_info_list_.Mutable(index);
}
inline ::GeneralTransInfo* BidRequest::add_trans_info_list() {
  return trans_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::GeneralTransInfo >&
BidRequest::trans_info_list() const {
  return trans_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::GeneralTransInfo >*
BidRequest::mutable_trans_info_list() {
  return &trans_info_list_;
}

// -------------------------------------------------------------------

// Imp

// required string id = 1;
inline bool Imp::has_id() const {
  return _has_bit(0);
}
inline void Imp::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Imp::id() const {
  return *id_;
}
inline void Imp::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Imp::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Imp::set_id(const char* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Imp::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// optional .Banner banner = 2;
inline bool Imp::has_banner() const {
  return _has_bit(1);
}
inline void Imp::clear_banner() {
  if (banner_ != NULL) banner_->::Banner::Clear();
  _clear_bit(1);
}
inline const ::Banner& Imp::banner() const {
  return banner_ != NULL ? *banner_ : *default_instance_->banner_;
}
inline ::Banner* Imp::mutable_banner() {
  _set_bit(1);
  if (banner_ == NULL) banner_ = new ::Banner;
  return banner_;
}

// optional string tagid = 7;
inline bool Imp::has_tagid() const {
  return _has_bit(2);
}
inline void Imp::clear_tagid() {
  if (tagid_ != &_default_tagid_) {
    tagid_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Imp::tagid() const {
  return *tagid_;
}
inline void Imp::set_tagid(const ::std::string& value) {
  _set_bit(2);
  if (tagid_ == &_default_tagid_) {
    tagid_ = new ::std::string;
  }
  tagid_->assign(value);
}
inline void Imp::set_tagid(const char* value) {
  _set_bit(2);
  if (tagid_ == &_default_tagid_) {
    tagid_ = new ::std::string;
  }
  tagid_->assign(value);
}
inline void Imp::set_tagid(const char* value, size_t size) {
  _set_bit(2);
  if (tagid_ == &_default_tagid_) {
    tagid_ = new ::std::string;
  }
  tagid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Imp::mutable_tagid() {
  _set_bit(2);
  if (tagid_ == &_default_tagid_) {
    tagid_ = new ::std::string;
  }
  return tagid_;
}

// optional double bidfloor = 8;
inline bool Imp::has_bidfloor() const {
  return _has_bit(3);
}
inline void Imp::clear_bidfloor() {
  bidfloor_ = 0;
  _clear_bit(3);
}
inline double Imp::bidfloor() const {
  return bidfloor_;
}
inline void Imp::set_bidfloor(double value) {
  _set_bit(3);
  bidfloor_ = value;
}

// optional bool secure = 12;
inline bool Imp::has_secure() const {
  return _has_bit(4);
}
inline void Imp::clear_secure() {
  secure_ = false;
  _clear_bit(4);
}
inline bool Imp::secure() const {
  return secure_;
}
inline void Imp::set_secure(bool value) {
  _set_bit(4);
  secure_ = value;
}

// optional .Native native = 13;
inline bool Imp::has_native() const {
  return _has_bit(5);
}
inline void Imp::clear_native() {
  if (native_ != NULL) native_->::Native::Clear();
  _clear_bit(5);
}
inline const ::Native& Imp::native() const {
  return native_ != NULL ? *native_ : *default_instance_->native_;
}
inline ::Native* Imp::mutable_native() {
  _set_bit(5);
  if (native_ == NULL) native_ = new ::Native;
  return native_;
}

// repeated string templelist = 100;
inline int Imp::templelist_size() const {
  return templelist_.size();
}
inline void Imp::clear_templelist() {
  templelist_.Clear();
}
inline const ::std::string& Imp::templelist(int index) const {
  return templelist_.Get(index);
}
inline ::std::string* Imp::mutable_templelist(int index) {
  return templelist_.Mutable(index);
}
inline void Imp::set_templelist(int index, const ::std::string& value) {
  templelist_.Mutable(index)->assign(value);
}
inline void Imp::set_templelist(int index, const char* value) {
  templelist_.Mutable(index)->assign(value);
}
inline void Imp::set_templelist(int index, const char* value, size_t size) {
  templelist_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Imp::add_templelist() {
  return templelist_.Add();
}
inline void Imp::add_templelist(const ::std::string& value) {
  templelist_.Add()->assign(value);
}
inline void Imp::add_templelist(const char* value) {
  templelist_.Add()->assign(value);
}
inline void Imp::add_templelist(const char* value, size_t size) {
  templelist_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Imp::templelist() const {
  return templelist_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Imp::mutable_templelist() {
  return &templelist_;
}

// -------------------------------------------------------------------

// Banner

// optional int32 w = 1;
inline bool Banner::has_w() const {
  return _has_bit(0);
}
inline void Banner::clear_w() {
  w_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 Banner::w() const {
  return w_;
}
inline void Banner::set_w(::google::protobuf::int32 value) {
  _set_bit(0);
  w_ = value;
}

// optional int32 h = 2;
inline bool Banner::has_h() const {
  return _has_bit(1);
}
inline void Banner::clear_h() {
  h_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 Banner::h() const {
  return h_;
}
inline void Banner::set_h(::google::protobuf::int32 value) {
  _set_bit(1);
  h_ = value;
}

// optional .AdPosition pos = 4;
inline bool Banner::has_pos() const {
  return _has_bit(2);
}
inline void Banner::clear_pos() {
  pos_ = 0;
  _clear_bit(2);
}
inline AdPosition Banner::pos() const {
  return static_cast< AdPosition >(pos_);
}
inline void Banner::set_pos(AdPosition value) {
  GOOGLE_DCHECK(AdPosition_IsValid(value));
  _set_bit(2);
  pos_ = value;
}

// -------------------------------------------------------------------

// Native

// optional .NativeRequest request_native = 50;
inline bool Native::has_request_native() const {
  return _has_bit(0);
}
inline void Native::clear_request_native() {
  if (request_native_ != NULL) request_native_->::NativeRequest::Clear();
  _clear_bit(0);
}
inline const ::NativeRequest& Native::request_native() const {
  return request_native_ != NULL ? *request_native_ : *default_instance_->request_native_;
}
inline ::NativeRequest* Native::mutable_request_native() {
  _set_bit(0);
  if (request_native_ == NULL) request_native_ = new ::NativeRequest;
  return request_native_;
}

// -------------------------------------------------------------------

// GeneralTransInfo

// required string key = 1;
inline bool GeneralTransInfo::has_key() const {
  return _has_bit(0);
}
inline void GeneralTransInfo::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& GeneralTransInfo::key() const {
  return *key_;
}
inline void GeneralTransInfo::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void GeneralTransInfo::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void GeneralTransInfo::set_key(const char* value, size_t size) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeneralTransInfo::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// optional string value = 2;
inline bool GeneralTransInfo::has_value() const {
  return _has_bit(1);
}
inline void GeneralTransInfo::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& GeneralTransInfo::value() const {
  return *value_;
}
inline void GeneralTransInfo::set_value(const ::std::string& value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void GeneralTransInfo::set_value(const char* value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void GeneralTransInfo::set_value(const char* value, size_t size) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GeneralTransInfo::mutable_value() {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// repeated .Pair value_list = 3;
inline int GeneralTransInfo::value_list_size() const {
  return value_list_.size();
}
inline void GeneralTransInfo::clear_value_list() {
  value_list_.Clear();
}
inline const ::Pair& GeneralTransInfo::value_list(int index) const {
  return value_list_.Get(index);
}
inline ::Pair* GeneralTransInfo::mutable_value_list(int index) {
  return value_list_.Mutable(index);
}
inline ::Pair* GeneralTransInfo::add_value_list() {
  return value_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Pair >&
GeneralTransInfo::value_list() const {
  return value_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::Pair >*
GeneralTransInfo::mutable_value_list() {
  return &value_list_;
}

// -------------------------------------------------------------------

// Pair

// optional string key = 1;
inline bool Pair::has_key() const {
  return _has_bit(0);
}
inline void Pair::clear_key() {
  if (key_ != &_default_key_) {
    key_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Pair::key() const {
  return *key_;
}
inline void Pair::set_key(const ::std::string& value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Pair::set_key(const char* value) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Pair::set_key(const char* value, size_t size) {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Pair::mutable_key() {
  _set_bit(0);
  if (key_ == &_default_key_) {
    key_ = new ::std::string;
  }
  return key_;
}

// optional string value = 2;
inline bool Pair::has_value() const {
  return _has_bit(1);
}
inline void Pair::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Pair::value() const {
  return *value_;
}
inline void Pair::set_value(const ::std::string& value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Pair::set_value(const char* value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Pair::set_value(const char* value, size_t size) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Pair::mutable_value() {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// -------------------------------------------------------------------

// Site

// optional string name = 2;
inline bool Site::has_name() const {
  return _has_bit(0);
}
inline void Site::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Site::name() const {
  return *name_;
}
inline void Site::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Site::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Site::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Site::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string domain = 3;
inline bool Site::has_domain() const {
  return _has_bit(1);
}
inline void Site::clear_domain() {
  if (domain_ != &_default_domain_) {
    domain_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Site::domain() const {
  return *domain_;
}
inline void Site::set_domain(const ::std::string& value) {
  _set_bit(1);
  if (domain_ == &_default_domain_) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void Site::set_domain(const char* value) {
  _set_bit(1);
  if (domain_ == &_default_domain_) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void Site::set_domain(const char* value, size_t size) {
  _set_bit(1);
  if (domain_ == &_default_domain_) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Site::mutable_domain() {
  _set_bit(1);
  if (domain_ == &_default_domain_) {
    domain_ = new ::std::string;
  }
  return domain_;
}

// optional string page = 7;
inline bool Site::has_page() const {
  return _has_bit(2);
}
inline void Site::clear_page() {
  if (page_ != &_default_page_) {
    page_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& Site::page() const {
  return *page_;
}
inline void Site::set_page(const ::std::string& value) {
  _set_bit(2);
  if (page_ == &_default_page_) {
    page_ = new ::std::string;
  }
  page_->assign(value);
}
inline void Site::set_page(const char* value) {
  _set_bit(2);
  if (page_ == &_default_page_) {
    page_ = new ::std::string;
  }
  page_->assign(value);
}
inline void Site::set_page(const char* value, size_t size) {
  _set_bit(2);
  if (page_ == &_default_page_) {
    page_ = new ::std::string;
  }
  page_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Site::mutable_page() {
  _set_bit(2);
  if (page_ == &_default_page_) {
    page_ = new ::std::string;
  }
  return page_;
}

// optional string ref = 9;
inline bool Site::has_ref() const {
  return _has_bit(3);
}
inline void Site::clear_ref() {
  if (ref_ != &_default_ref_) {
    ref_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Site::ref() const {
  return *ref_;
}
inline void Site::set_ref(const ::std::string& value) {
  _set_bit(3);
  if (ref_ == &_default_ref_) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
}
inline void Site::set_ref(const char* value) {
  _set_bit(3);
  if (ref_ == &_default_ref_) {
    ref_ = new ::std::string;
  }
  ref_->assign(value);
}
inline void Site::set_ref(const char* value, size_t size) {
  _set_bit(3);
  if (ref_ == &_default_ref_) {
    ref_ = new ::std::string;
  }
  ref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Site::mutable_ref() {
  _set_bit(3);
  if (ref_ == &_default_ref_) {
    ref_ = new ::std::string;
  }
  return ref_;
}

// -------------------------------------------------------------------

// App

// optional string id = 1;
inline bool App::has_id() const {
  return _has_bit(0);
}
inline void App::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& App::id() const {
  return *id_;
}
inline void App::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void App::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void App::set_id(const char* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// optional string name = 2;
inline bool App::has_name() const {
  return _has_bit(1);
}
inline void App::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& App::name() const {
  return *name_;
}
inline void App::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void App::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void App::set_name(const char* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string ver = 7;
inline bool App::has_ver() const {
  return _has_bit(2);
}
inline void App::clear_ver() {
  if (ver_ != &_default_ver_) {
    ver_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& App::ver() const {
  return *ver_;
}
inline void App::set_ver(const ::std::string& value) {
  _set_bit(2);
  if (ver_ == &_default_ver_) {
    ver_ = new ::std::string;
  }
  ver_->assign(value);
}
inline void App::set_ver(const char* value) {
  _set_bit(2);
  if (ver_ == &_default_ver_) {
    ver_ = new ::std::string;
  }
  ver_->assign(value);
}
inline void App::set_ver(const char* value, size_t size) {
  _set_bit(2);
  if (ver_ == &_default_ver_) {
    ver_ = new ::std::string;
  }
  ver_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_ver() {
  _set_bit(2);
  if (ver_ == &_default_ver_) {
    ver_ = new ::std::string;
  }
  return ver_;
}

// optional string bundle = 8;
inline bool App::has_bundle() const {
  return _has_bit(3);
}
inline void App::clear_bundle() {
  if (bundle_ != &_default_bundle_) {
    bundle_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& App::bundle() const {
  return *bundle_;
}
inline void App::set_bundle(const ::std::string& value) {
  _set_bit(3);
  if (bundle_ == &_default_bundle_) {
    bundle_ = new ::std::string;
  }
  bundle_->assign(value);
}
inline void App::set_bundle(const char* value) {
  _set_bit(3);
  if (bundle_ == &_default_bundle_) {
    bundle_ = new ::std::string;
  }
  bundle_->assign(value);
}
inline void App::set_bundle(const char* value, size_t size) {
  _set_bit(3);
  if (bundle_ == &_default_bundle_) {
    bundle_ = new ::std::string;
  }
  bundle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* App::mutable_bundle() {
  _set_bit(3);
  if (bundle_ == &_default_bundle_) {
    bundle_ = new ::std::string;
  }
  return bundle_;
}

// -------------------------------------------------------------------

// Device

// optional string ua = 2;
inline bool Device::has_ua() const {
  return _has_bit(0);
}
inline void Device::clear_ua() {
  if (ua_ != &_default_ua_) {
    ua_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Device::ua() const {
  return *ua_;
}
inline void Device::set_ua(const ::std::string& value) {
  _set_bit(0);
  if (ua_ == &_default_ua_) {
    ua_ = new ::std::string;
  }
  ua_->assign(value);
}
inline void Device::set_ua(const char* value) {
  _set_bit(0);
  if (ua_ == &_default_ua_) {
    ua_ = new ::std::string;
  }
  ua_->assign(value);
}
inline void Device::set_ua(const char* value, size_t size) {
  _set_bit(0);
  if (ua_ == &_default_ua_) {
    ua_ = new ::std::string;
  }
  ua_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_ua() {
  _set_bit(0);
  if (ua_ == &_default_ua_) {
    ua_ = new ::std::string;
  }
  return ua_;
}

// optional string ip = 3;
inline bool Device::has_ip() const {
  return _has_bit(1);
}
inline void Device::clear_ip() {
  if (ip_ != &_default_ip_) {
    ip_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& Device::ip() const {
  return *ip_;
}
inline void Device::set_ip(const ::std::string& value) {
  _set_bit(1);
  if (ip_ == &_default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Device::set_ip(const char* value) {
  _set_bit(1);
  if (ip_ == &_default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void Device::set_ip(const char* value, size_t size) {
  _set_bit(1);
  if (ip_ == &_default_ip_) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_ip() {
  _set_bit(1);
  if (ip_ == &_default_ip_) {
    ip_ = new ::std::string;
  }
  return ip_;
}

// optional .Geo geo = 4;
inline bool Device::has_geo() const {
  return _has_bit(2);
}
inline void Device::clear_geo() {
  if (geo_ != NULL) geo_->::Geo::Clear();
  _clear_bit(2);
}
inline const ::Geo& Device::geo() const {
  return geo_ != NULL ? *geo_ : *default_instance_->geo_;
}
inline ::Geo* Device::mutable_geo() {
  _set_bit(2);
  if (geo_ == NULL) geo_ = new ::Geo;
  return geo_;
}

// optional string ipv6 = 9;
inline bool Device::has_ipv6() const {
  return _has_bit(3);
}
inline void Device::clear_ipv6() {
  if (ipv6_ != &_default_ipv6_) {
    ipv6_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& Device::ipv6() const {
  return *ipv6_;
}
inline void Device::set_ipv6(const ::std::string& value) {
  _set_bit(3);
  if (ipv6_ == &_default_ipv6_) {
    ipv6_ = new ::std::string;
  }
  ipv6_->assign(value);
}
inline void Device::set_ipv6(const char* value) {
  _set_bit(3);
  if (ipv6_ == &_default_ipv6_) {
    ipv6_ = new ::std::string;
  }
  ipv6_->assign(value);
}
inline void Device::set_ipv6(const char* value, size_t size) {
  _set_bit(3);
  if (ipv6_ == &_default_ipv6_) {
    ipv6_ = new ::std::string;
  }
  ipv6_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_ipv6() {
  _set_bit(3);
  if (ipv6_ == &_default_ipv6_) {
    ipv6_ = new ::std::string;
  }
  return ipv6_;
}

// optional string model = 13;
inline bool Device::has_model() const {
  return _has_bit(4);
}
inline void Device::clear_model() {
  if (model_ != &_default_model_) {
    model_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& Device::model() const {
  return *model_;
}
inline void Device::set_model(const ::std::string& value) {
  _set_bit(4);
  if (model_ == &_default_model_) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void Device::set_model(const char* value) {
  _set_bit(4);
  if (model_ == &_default_model_) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void Device::set_model(const char* value, size_t size) {
  _set_bit(4);
  if (model_ == &_default_model_) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_model() {
  _set_bit(4);
  if (model_ == &_default_model_) {
    model_ = new ::std::string;
  }
  return model_;
}

// optional string os = 14;
inline bool Device::has_os() const {
  return _has_bit(5);
}
inline void Device::clear_os() {
  if (os_ != &_default_os_) {
    os_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& Device::os() const {
  return *os_;
}
inline void Device::set_os(const ::std::string& value) {
  _set_bit(5);
  if (os_ == &_default_os_) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void Device::set_os(const char* value) {
  _set_bit(5);
  if (os_ == &_default_os_) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void Device::set_os(const char* value, size_t size) {
  _set_bit(5);
  if (os_ == &_default_os_) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_os() {
  _set_bit(5);
  if (os_ == &_default_os_) {
    os_ = new ::std::string;
  }
  return os_;
}

// optional string osv = 15;
inline bool Device::has_osv() const {
  return _has_bit(6);
}
inline void Device::clear_osv() {
  if (osv_ != &_default_osv_) {
    osv_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& Device::osv() const {
  return *osv_;
}
inline void Device::set_osv(const ::std::string& value) {
  _set_bit(6);
  if (osv_ == &_default_osv_) {
    osv_ = new ::std::string;
  }
  osv_->assign(value);
}
inline void Device::set_osv(const char* value) {
  _set_bit(6);
  if (osv_ == &_default_osv_) {
    osv_ = new ::std::string;
  }
  osv_->assign(value);
}
inline void Device::set_osv(const char* value, size_t size) {
  _set_bit(6);
  if (osv_ == &_default_osv_) {
    osv_ = new ::std::string;
  }
  osv_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_osv() {
  _set_bit(6);
  if (osv_ == &_default_osv_) {
    osv_ = new ::std::string;
  }
  return osv_;
}

// optional int32 w = 25;
inline bool Device::has_w() const {
  return _has_bit(7);
}
inline void Device::clear_w() {
  w_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 Device::w() const {
  return w_;
}
inline void Device::set_w(::google::protobuf::int32 value) {
  _set_bit(7);
  w_ = value;
}

// optional int32 h = 26;
inline bool Device::has_h() const {
  return _has_bit(8);
}
inline void Device::clear_h() {
  h_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 Device::h() const {
  return h_;
}
inline void Device::set_h(::google::protobuf::int32 value) {
  _set_bit(8);
  h_ = value;
}

// optional .ConnectionType connectiontype = 17;
inline bool Device::has_connectiontype() const {
  return _has_bit(9);
}
inline void Device::clear_connectiontype() {
  connectiontype_ = 0;
  _clear_bit(9);
}
inline ConnectionType Device::connectiontype() const {
  return static_cast< ConnectionType >(connectiontype_);
}
inline void Device::set_connectiontype(ConnectionType value) {
  GOOGLE_DCHECK(ConnectionType_IsValid(value));
  _set_bit(9);
  connectiontype_ = value;
}

// optional .DeviceType devicetype = 18;
inline bool Device::has_devicetype() const {
  return _has_bit(10);
}
inline void Device::clear_devicetype() {
  devicetype_ = 1;
  _clear_bit(10);
}
inline DeviceType Device::devicetype() const {
  return static_cast< DeviceType >(devicetype_);
}
inline void Device::set_devicetype(DeviceType value) {
  GOOGLE_DCHECK(DeviceType_IsValid(value));
  _set_bit(10);
  devicetype_ = value;
}

// optional string ifa = 20;
inline bool Device::has_ifa() const {
  return _has_bit(11);
}
inline void Device::clear_ifa() {
  if (ifa_ != &_default_ifa_) {
    ifa_->clear();
  }
  _clear_bit(11);
}
inline const ::std::string& Device::ifa() const {
  return *ifa_;
}
inline void Device::set_ifa(const ::std::string& value) {
  _set_bit(11);
  if (ifa_ == &_default_ifa_) {
    ifa_ = new ::std::string;
  }
  ifa_->assign(value);
}
inline void Device::set_ifa(const char* value) {
  _set_bit(11);
  if (ifa_ == &_default_ifa_) {
    ifa_ = new ::std::string;
  }
  ifa_->assign(value);
}
inline void Device::set_ifa(const char* value, size_t size) {
  _set_bit(11);
  if (ifa_ == &_default_ifa_) {
    ifa_ = new ::std::string;
  }
  ifa_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_ifa() {
  _set_bit(11);
  if (ifa_ == &_default_ifa_) {
    ifa_ = new ::std::string;
  }
  return ifa_;
}

// optional string macsha1 = 21;
inline bool Device::has_macsha1() const {
  return _has_bit(12);
}
inline void Device::clear_macsha1() {
  if (macsha1_ != &_default_macsha1_) {
    macsha1_->clear();
  }
  _clear_bit(12);
}
inline const ::std::string& Device::macsha1() const {
  return *macsha1_;
}
inline void Device::set_macsha1(const ::std::string& value) {
  _set_bit(12);
  if (macsha1_ == &_default_macsha1_) {
    macsha1_ = new ::std::string;
  }
  macsha1_->assign(value);
}
inline void Device::set_macsha1(const char* value) {
  _set_bit(12);
  if (macsha1_ == &_default_macsha1_) {
    macsha1_ = new ::std::string;
  }
  macsha1_->assign(value);
}
inline void Device::set_macsha1(const char* value, size_t size) {
  _set_bit(12);
  if (macsha1_ == &_default_macsha1_) {
    macsha1_ = new ::std::string;
  }
  macsha1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_macsha1() {
  _set_bit(12);
  if (macsha1_ == &_default_macsha1_) {
    macsha1_ = new ::std::string;
  }
  return macsha1_;
}

// optional string macmd5 = 22;
inline bool Device::has_macmd5() const {
  return _has_bit(13);
}
inline void Device::clear_macmd5() {
  if (macmd5_ != &_default_macmd5_) {
    macmd5_->clear();
  }
  _clear_bit(13);
}
inline const ::std::string& Device::macmd5() const {
  return *macmd5_;
}
inline void Device::set_macmd5(const ::std::string& value) {
  _set_bit(13);
  if (macmd5_ == &_default_macmd5_) {
    macmd5_ = new ::std::string;
  }
  macmd5_->assign(value);
}
inline void Device::set_macmd5(const char* value) {
  _set_bit(13);
  if (macmd5_ == &_default_macmd5_) {
    macmd5_ = new ::std::string;
  }
  macmd5_->assign(value);
}
inline void Device::set_macmd5(const char* value, size_t size) {
  _set_bit(13);
  if (macmd5_ == &_default_macmd5_) {
    macmd5_ = new ::std::string;
  }
  macmd5_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_macmd5() {
  _set_bit(13);
  if (macmd5_ == &_default_macmd5_) {
    macmd5_ = new ::std::string;
  }
  return macmd5_;
}

// optional string cuid = 100;
inline bool Device::has_cuid() const {
  return _has_bit(14);
}
inline void Device::clear_cuid() {
  if (cuid_ != &_default_cuid_) {
    cuid_->clear();
  }
  _clear_bit(14);
}
inline const ::std::string& Device::cuid() const {
  return *cuid_;
}
inline void Device::set_cuid(const ::std::string& value) {
  _set_bit(14);
  if (cuid_ == &_default_cuid_) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void Device::set_cuid(const char* value) {
  _set_bit(14);
  if (cuid_ == &_default_cuid_) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(value);
}
inline void Device::set_cuid(const char* value, size_t size) {
  _set_bit(14);
  if (cuid_ == &_default_cuid_) {
    cuid_ = new ::std::string;
  }
  cuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_cuid() {
  _set_bit(14);
  if (cuid_ == &_default_cuid_) {
    cuid_ = new ::std::string;
  }
  return cuid_;
}

// optional string android_id = 101;
inline bool Device::has_android_id() const {
  return _has_bit(15);
}
inline void Device::clear_android_id() {
  if (android_id_ != &_default_android_id_) {
    android_id_->clear();
  }
  _clear_bit(15);
}
inline const ::std::string& Device::android_id() const {
  return *android_id_;
}
inline void Device::set_android_id(const ::std::string& value) {
  _set_bit(15);
  if (android_id_ == &_default_android_id_) {
    android_id_ = new ::std::string;
  }
  android_id_->assign(value);
}
inline void Device::set_android_id(const char* value) {
  _set_bit(15);
  if (android_id_ == &_default_android_id_) {
    android_id_ = new ::std::string;
  }
  android_id_->assign(value);
}
inline void Device::set_android_id(const char* value, size_t size) {
  _set_bit(15);
  if (android_id_ == &_default_android_id_) {
    android_id_ = new ::std::string;
  }
  android_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Device::mutable_android_id() {
  _set_bit(15);
  if (android_id_ == &_default_android_id_) {
    android_id_ = new ::std::string;
  }
  return android_id_;
}

// -------------------------------------------------------------------

// Geo

// optional double lat = 1;
inline bool Geo::has_lat() const {
  return _has_bit(0);
}
inline void Geo::clear_lat() {
  lat_ = 0;
  _clear_bit(0);
}
inline double Geo::lat() const {
  return lat_;
}
inline void Geo::set_lat(double value) {
  _set_bit(0);
  lat_ = value;
}

// optional double lon = 2;
inline bool Geo::has_lon() const {
  return _has_bit(1);
}
inline void Geo::clear_lon() {
  lon_ = 0;
  _clear_bit(1);
}
inline double Geo::lon() const {
  return lon_;
}
inline void Geo::set_lon(double value) {
  _set_bit(1);
  lon_ = value;
}

// optional .LocationType type = 9;
inline bool Geo::has_type() const {
  return _has_bit(2);
}
inline void Geo::clear_type() {
  type_ = 1;
  _clear_bit(2);
}
inline LocationType Geo::type() const {
  return static_cast< LocationType >(type_);
}
inline void Geo::set_type(LocationType value) {
  GOOGLE_DCHECK(LocationType_IsValid(value));
  _set_bit(2);
  type_ = value;
}

// -------------------------------------------------------------------

// User

// optional string id = 1;
inline bool User::has_id() const {
  return _has_bit(0);
}
inline void User::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& User::id() const {
  return *id_;
}
inline void User::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void User::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void User::set_id(const char* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// optional string buyeruid = 2;
inline bool User::has_buyeruid() const {
  return _has_bit(1);
}
inline void User::clear_buyeruid() {
  if (buyeruid_ != &_default_buyeruid_) {
    buyeruid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& User::buyeruid() const {
  return *buyeruid_;
}
inline void User::set_buyeruid(const ::std::string& value) {
  _set_bit(1);
  if (buyeruid_ == &_default_buyeruid_) {
    buyeruid_ = new ::std::string;
  }
  buyeruid_->assign(value);
}
inline void User::set_buyeruid(const char* value) {
  _set_bit(1);
  if (buyeruid_ == &_default_buyeruid_) {
    buyeruid_ = new ::std::string;
  }
  buyeruid_->assign(value);
}
inline void User::set_buyeruid(const char* value, size_t size) {
  _set_bit(1);
  if (buyeruid_ == &_default_buyeruid_) {
    buyeruid_ = new ::std::string;
  }
  buyeruid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_buyeruid() {
  _set_bit(1);
  if (buyeruid_ == &_default_buyeruid_) {
    buyeruid_ = new ::std::string;
  }
  return buyeruid_;
}

// optional int32 yob = 3;
inline bool User::has_yob() const {
  return _has_bit(2);
}
inline void User::clear_yob() {
  yob_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 User::yob() const {
  return yob_;
}
inline void User::set_yob(::google::protobuf::int32 value) {
  _set_bit(2);
  yob_ = value;
}

// optional string gender = 4;
inline bool User::has_gender() const {
  return _has_bit(3);
}
inline void User::clear_gender() {
  if (gender_ != &_default_gender_) {
    gender_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& User::gender() const {
  return *gender_;
}
inline void User::set_gender(const ::std::string& value) {
  _set_bit(3);
  if (gender_ == &_default_gender_) {
    gender_ = new ::std::string;
  }
  gender_->assign(value);
}
inline void User::set_gender(const char* value) {
  _set_bit(3);
  if (gender_ == &_default_gender_) {
    gender_ = new ::std::string;
  }
  gender_->assign(value);
}
inline void User::set_gender(const char* value, size_t size) {
  _set_bit(3);
  if (gender_ == &_default_gender_) {
    gender_ = new ::std::string;
  }
  gender_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_gender() {
  _set_bit(3);
  if (gender_ == &_default_gender_) {
    gender_ = new ::std::string;
  }
  return gender_;
}

// optional string keywords = 5;
inline bool User::has_keywords() const {
  return _has_bit(4);
}
inline void User::clear_keywords() {
  if (keywords_ != &_default_keywords_) {
    keywords_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& User::keywords() const {
  return *keywords_;
}
inline void User::set_keywords(const ::std::string& value) {
  _set_bit(4);
  if (keywords_ == &_default_keywords_) {
    keywords_ = new ::std::string;
  }
  keywords_->assign(value);
}
inline void User::set_keywords(const char* value) {
  _set_bit(4);
  if (keywords_ == &_default_keywords_) {
    keywords_ = new ::std::string;
  }
  keywords_->assign(value);
}
inline void User::set_keywords(const char* value, size_t size) {
  _set_bit(4);
  if (keywords_ == &_default_keywords_) {
    keywords_ = new ::std::string;
  }
  keywords_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_keywords() {
  _set_bit(4);
  if (keywords_ == &_default_keywords_) {
    keywords_ = new ::std::string;
  }
  return keywords_;
}

// optional .Geo geo = 7;
inline bool User::has_geo() const {
  return _has_bit(5);
}
inline void User::clear_geo() {
  if (geo_ != NULL) geo_->::Geo::Clear();
  _clear_bit(5);
}
inline const ::Geo& User::geo() const {
  return geo_ != NULL ? *geo_ : *default_instance_->geo_;
}
inline ::Geo* User::mutable_geo() {
  _set_bit(5);
  if (geo_ == NULL) geo_ = new ::Geo;
  return geo_;
}

// optional string baiduid = 100;
inline bool User::has_baiduid() const {
  return _has_bit(6);
}
inline void User::clear_baiduid() {
  if (baiduid_ != &_default_baiduid_) {
    baiduid_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& User::baiduid() const {
  return *baiduid_;
}
inline void User::set_baiduid(const ::std::string& value) {
  _set_bit(6);
  if (baiduid_ == &_default_baiduid_) {
    baiduid_ = new ::std::string;
  }
  baiduid_->assign(value);
}
inline void User::set_baiduid(const char* value) {
  _set_bit(6);
  if (baiduid_ == &_default_baiduid_) {
    baiduid_ = new ::std::string;
  }
  baiduid_->assign(value);
}
inline void User::set_baiduid(const char* value, size_t size) {
  _set_bit(6);
  if (baiduid_ == &_default_baiduid_) {
    baiduid_ = new ::std::string;
  }
  baiduid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* User::mutable_baiduid() {
  _set_bit(6);
  if (baiduid_ == &_default_baiduid_) {
    baiduid_ = new ::std::string;
  }
  return baiduid_;
}

// -------------------------------------------------------------------

// NativeRequest

// optional .LayoutId layout = 2;
inline bool NativeRequest::has_layout() const {
  return _has_bit(0);
}
inline void NativeRequest::clear_layout() {
  layout_ = 1;
  _clear_bit(0);
}
inline LayoutId NativeRequest::layout() const {
  return static_cast< LayoutId >(layout_);
}
inline void NativeRequest::set_layout(LayoutId value) {
  GOOGLE_DCHECK(LayoutId_IsValid(value));
  _set_bit(0);
  layout_ = value;
}

// optional .ContextType context = 7;
inline bool NativeRequest::has_context() const {
  return _has_bit(1);
}
inline void NativeRequest::clear_context() {
  context_ = 1;
  _clear_bit(1);
}
inline ContextType NativeRequest::context() const {
  return static_cast< ContextType >(context_);
}
inline void NativeRequest::set_context(ContextType value) {
  GOOGLE_DCHECK(ContextType_IsValid(value));
  _set_bit(1);
  context_ = value;
}

// optional .ContextSubtype contextsubtype = 8;
inline bool NativeRequest::has_contextsubtype() const {
  return _has_bit(2);
}
inline void NativeRequest::clear_contextsubtype() {
  contextsubtype_ = 10;
  _clear_bit(2);
}
inline ContextSubtype NativeRequest::contextsubtype() const {
  return static_cast< ContextSubtype >(contextsubtype_);
}
inline void NativeRequest::set_contextsubtype(ContextSubtype value) {
  GOOGLE_DCHECK(ContextSubtype_IsValid(value));
  _set_bit(2);
  contextsubtype_ = value;
}

// optional .PlacementType plcmttype = 9;
inline bool NativeRequest::has_plcmttype() const {
  return _has_bit(3);
}
inline void NativeRequest::clear_plcmttype() {
  plcmttype_ = 1;
  _clear_bit(3);
}
inline PlacementType NativeRequest::plcmttype() const {
  return static_cast< PlacementType >(plcmttype_);
}
inline void NativeRequest::set_plcmttype(PlacementType value) {
  GOOGLE_DCHECK(PlacementType_IsValid(value));
  _set_bit(3);
  plcmttype_ = value;
}

// optional int32 plcmtcnt = 4;
inline bool NativeRequest::has_plcmtcnt() const {
  return _has_bit(4);
}
inline void NativeRequest::clear_plcmtcnt() {
  plcmtcnt_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 NativeRequest::plcmtcnt() const {
  return plcmtcnt_;
}
inline void NativeRequest::set_plcmtcnt(::google::protobuf::int32 value) {
  _set_bit(4);
  plcmtcnt_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< AuctionType>() {
  return AuctionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< BannerAdType>() {
  return BannerAdType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< CreativeAttribute>() {
  return CreativeAttribute_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< APIFramework>() {
  return APIFramework_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< AdPosition>() {
  return AdPosition_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< VideoLinearity>() {
  return VideoLinearity_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< Protocol>() {
  return Protocol_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< PlaybackMethod>() {
  return PlaybackMethod_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< StartDelay>() {
  return StartDelay_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ConnectionType>() {
  return ConnectionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ExpandableDirection>() {
  return ExpandableDirection_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ContentDeliveryMethod>() {
  return ContentDeliveryMethod_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ContentContext>() {
  return ContentContext_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ProductionQuality>() {
  return ProductionQuality_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< LocationType>() {
  return LocationType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< LocationService>() {
  return LocationService_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< DeviceType>() {
  return DeviceType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< CompanionType>() {
  return CompanionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< QAGMediaRating>() {
  return QAGMediaRating_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< NoBidReason>() {
  return NoBidReason_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< FeedType>() {
  return FeedType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< VolumeNormalizationMode>() {
  return VolumeNormalizationMode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< LayoutId>() {
  return LayoutId_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< AdUnitId>() {
  return AdUnitId_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ContextType>() {
  return ContextType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ContextSubtype>() {
  return ContextSubtype_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< PlacementType>() {
  return PlacementType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< DataAssetType>() {
  return DataAssetType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ImageAssetType>() {
  return ImageAssetType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_BidRequest_2eproto__INCLUDED
